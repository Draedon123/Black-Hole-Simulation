(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))i(s);new MutationObserver(s=>{for(const r of s)if(r.type==="childList")for(const n of r.addedNodes)n.tagName==="LINK"&&n.rel==="modulepreload"&&i(n)}).observe(document,{childList:!0,subtree:!0});function t(s){const r={};return s.integrity&&(r.integrity=s.integrity),s.referrerPolicy&&(r.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?r.credentials="include":s.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function i(s){if(s.ep)return;s.ep=!0;const r=t(s);fetch(s.href,r)}})();class c{components;constructor(e=0,t=0,i=0){this.components=new Float32Array(3),this.components[0]=e,this.components[1]=t,this.components[2]=i}static scale(e,t){return new c(e.components[0]*t,e.components[1]*t,e.components[2]*t)}static add(e,t){return e.clone().add(t)}static subtract(e,t){return e.clone().subtract(t)}static cross(e,t){const i=e.components[0],s=e.components[1],r=e.components[2],n=t.components[0],o=t.components[1],l=t.components[2];return new c(s*l-r*o,r*n-i*l,i*o-s*n)}add(e){return this.components[0]+=e.components[0],this.components[1]+=e.components[1],this.components[2]+=e.components[2],this}subtract(e){return this.components[0]-=e.components[0],this.components[1]-=e.components[1],this.components[2]-=e.components[2],this}scale(e){return this.components[0]*=e,this.components[1]*=e,this.components[2]*=e,this}normalise(){const e=1/this.magnitude;return this.components[0]*=e,this.components[1]*=e,this.components[2]*=e,this}clone(){return new c(this.components[0],this.components[1],this.components[2])}get magnitude(){return Math.hypot(this.components[0],this.components[1],this.components[2])}get x(){return this.components[0]}get y(){return this.components[1]}get z(){return this.components[2]}set x(e){this.components[0]=e}set y(e){this.components[1]=e}set z(e){this.components[2]=e}}class f{buffer;dataview;littleEndian;offset;constructor(e,t=!0,i=0){this.buffer=new ArrayBuffer(e),this.dataview=new DataView(this.buffer),this.littleEndian=t,this.offset=i}writeUint8(e){this.dataview.setUint8(this.offset,e),this.offset+=1}writeFloat32(e){this.dataview.setFloat32(this.offset,e,this.littleEndian),this.offset+=4}writeUint32(e){this.dataview.setUint32(this.offset,e,this.littleEndian),this.offset+=4}writeVec3f(e){this.writeFloat32(e.x),this.writeFloat32(e.y),this.writeFloat32(e.z)}writeMat4x4f(e){for(let t=0;t<16;t++)this.writeFloat32(e.components[t])}pad(e){this.offset+=e}}class S{samples;maxSamples;constructor(e){this.samples=[],this.maxSamples=e}get average(){return this.samples.reduce((e,t)=>e+t,0)/this.samples.length}addSample(e){this.samples.length===this.maxSamples&&this.samples.shift(),this.samples.push(e)}reset(){this.samples.splice(0,this.samples.length)}}class g{static modifiedDevices=new Set;querySet;resolveBuffer;resultBuffer;canTimestamp;rollingAverage;onUpdate;constructor(e,t=()=>{}){if(this.canTimestamp=e.features.has("timestamp-query"),this.onUpdate=t,this.rollingAverage=new S(100),this.querySet=e.createQuerySet({label:"GPUTimer Query Set",type:"timestamp",count:2}),this.resolveBuffer=e.createBuffer({label:"GPUTimer Resolve Buffer",size:this.querySet.count*BigInt64Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.QUERY_RESOLVE|GPUBufferUsage.COPY_SRC}),this.resultBuffer=e.createBuffer({label:"GPUTimer Result Buffer",size:this.resolveBuffer.size,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),!g.modifiedDevices.has(e)){const i=e.queue.submit.bind(e.queue);e.queue.submit=s=>{i(s),!(!this.canTimestamp||this.resultBuffer.mapState!=="unmapped")&&this.resultBuffer.mapAsync(GPUMapMode.READ).then(()=>{const r=new BigInt64Array(this.resultBuffer.getMappedRange());this.rollingAverage.addSample(Number(r[1]-r[0])),this.resultBuffer.unmap(),this.onUpdate(this.rollingAverage.average)})},g.modifiedDevices.add(e)}}get time(){return this.rollingAverage.average}beginComputePass(e,t){const i={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1},s=e.beginComputePass({...t,...this.canTimestamp?{timestampWrites:i}:void 0}),r=s.end.bind(s);return s.end=()=>{r(),this.canTimestamp&&(e.resolveQuerySet(this.querySet,0,this.querySet.count,this.resolveBuffer,0),this.resultBuffer.mapState==="unmapped"&&e.copyBufferToBuffer(this.resolveBuffer,this.resultBuffer))},s}reset(){this.rollingAverage.reset()}}function E(a){return`/Black-Hole-Simulation/${a}`}function b(a){return a+16-a%16}const v=66743e-15,p=299792458;class T{static BYTE_LENGTH=b(6*Float32Array.BYTES_PER_ELEMENT);buffer;initialised;device;position;mass;radius;spinParameter;constructor(e={}){this.initialised=!1,this.position=e.position??new c,this.mass=e.mass??1e31,this.radius=e.radius??1e7,this.spinParameter=e.spinParameter??.99}initialise(e){this.initialised||(this.device=e,this.buffer=this.device.createBuffer({label:"Black Hole Buffer",size:T.BYTE_LENGTH,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.initialised=!0,this.updateBuffer())}updateBuffer(){this.initialised||console.error("Black Hole not initialised"),this.device.queue.writeBuffer(this.buffer,0,this.serialise())}serialise(){const e=new f(T.BYTE_LENGTH);return e.writeVec3f(this.position),e.writeFloat32(this.mass),e.writeFloat32(this.schwarzschildRadius),e.writeFloat32(this.kerrParameter),e.buffer}get schwarzschildRadius(){return 2*v*this.mass/(p*p)}get kerrParameter(){return this.spinParameter*v*this.mass/(p*p)}}class m{static BYTE_LENGTH=b(18*Float32Array.BYTES_PER_ELEMENT);static GLOBAL_UP=new c(0,1,0);imageWidth;imageHeight;fieldOfView;position;lookAt;up;right;back;viewportDeltaU;viewportDeltaV;pixel00;initialised;device;buffer;constructor(e={}){this.imageWidth=e.imageWidth??1920,this.imageHeight=e.imageHeight??1080,this.fieldOfView=e.fieldOfView??Math.PI/3,this.position=e.position??new c,this.lookAt=e.lookAt??new c(0,0,-1),this.initialised=!1}serialise(){const e=new f(m.BYTE_LENGTH);return e.writeVec3f(this.position),e.pad(4),e.writeVec3f(this.viewportDeltaU),e.pad(4),e.writeVec3f(this.viewportDeltaV),e.pad(4),e.writeVec3f(this.pixel00),e.pad(4),e.writeFloat32(this.imageWidth),e.writeFloat32(this.imageHeight),e.buffer}initialise(e){this.initialised||(this.device=e,this.buffer=e.createBuffer({label:"Camera Buffer",size:m.BYTE_LENGTH,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.initialised=!0,this.updateBuffer())}updateBuffer(){if(!this.initialised)return;const e=this.imageWidth/this.imageHeight,t=c.subtract(this.position,this.lookAt).magnitude;if(t<1e-8){console.error("Look At is too close to Position. Buffer not updated");return}const i=2*t*Math.tan(this.fieldOfView/2),s=e*i;this.back=c.subtract(this.position,this.lookAt).normalise(),this.right=c.cross(m.GLOBAL_UP,this.back),this.up=c.cross(this.back,this.right);const r=c.scale(this.right,s),n=c.scale(this.up,i);this.viewportDeltaU=c.scale(r,1/this.imageWidth),this.viewportDeltaV=c.scale(n,1/this.imageHeight);const o=this.position.clone().subtract(c.scale(this.back,t));this.pixel00=o.subtract(c.add(r,n).scale(.5)).add(c.add(this.viewportDeltaU,this.viewportDeltaV).scale(.5)),this.device.queue.writeBuffer(this.buffer,0,this.serialise())}setImageDimensions(e,t){this.imageWidth=e,this.imageHeight=t,this.updateBuffer()}get aspectRatio(){return this.imageWidth/this.imageHeight}}class d{shader;constructor(e,t,i){this.shader=e.createShaderModule({label:i,code:t})}static async fetch(e,t,i){const s=await(await fetch(t)).text(),r=await d.preprocess(t,s);return new d(e,r,i)}static async preprocess(e,t){return d.resolveImports(e,t)}static async resolveImports(e,t,i=[]){const s=/#!import.*\s/g,r=e.split("/"),n=r.slice(0,r.length-1).join("/")+"/",o=t.match(s)?.map(u=>u.replaceAll(/(#!import)|\s/g,"")).filter(u=>!i.includes(u)).map(u=>n+u+".wgsl")??[];return((await Promise.all(o.map(async u=>{const B=await(await fetch(u)).text();return d.resolveImports(u,B,i)}))).join("")+t).replaceAll(s,"")}}class w{label;texture;constructor(e,t){this.label=e,this.texture=t}static async create(e,t,...i){const s=i.map(async l=>await(await fetch(E(l))).blob()),r=await Promise.all(s),n=await Promise.all(r.map(l=>createImageBitmap(l))),o=e.createTexture({label:t,format:"rgba8unorm",size:[n[0].width,n[0].height,n.length],usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});for(let l=0;l<n.length;l++){const u=n[l];e.queue.copyExternalImageToTexture({source:u},{texture:o,origin:[0,0,l]},{width:u.width,height:u.height})}return new w(t,o)}static async createCubemap(e,t,i){return await w.create(e,t,`${i}/px.png`,`${i}/nx.png`,`${i}/py.png`,`${i}/ny.png`,`${i}/pz.png`,`${i}/nz.png`)}}class h{static RENDER_SETTINGS_BYTE_LENGTH=b(1*Float32Array.BYTES_PER_ELEMENT);static COMPUTE_SETTINGS_BYTE_LENGTH=b(1*Float32Array.BYTES_PER_ELEMENT);canvas;camera;settings;device;ctx;canvasFormat;gpuTimer;blackHole;initialised;skybox;renderSettingsBuffer;renderBindGroupLayout;renderBindGroup;renderPipeline;renderTexture;sampler;computeSettingsBuffer;computeBindGroupLayout;computeBindGroup;computePipeline;constructor(e,t,i){const s=e.getContext("webgpu");if(s===null)throw new Error("Could not create WebGPU Canvas Context");this.canvas=e,this.device=i,this.ctx=s,this.canvasFormat="rgba8unorm",this.camera=new m,this.blackHole=new T(t.blackHole),this.gpuTimer=new g(this.device,r=>{const n=r/1e3,o=r/1e6,l=r/1e9,u=o>1,B=(u?o:n).toFixed(2),y=u?"ms":"Î¼s";if(this.settings.timing?.frameTimeElement!==void 0&&(this.settings.timing.frameTimeElement.textContent=B+y),this.settings.timing?.fpsElement!==void 0){const P=1/l;this.settings.timing.fpsElement.textContent=P.toFixed(2)}}),this.initialised=!1,this.settings={gamma:t.gamma??1.5,numberOfSteps:t.numberOfSteps??1e3,timing:t.timing}}serialiseRenderSettings(){const e=new f(h.RENDER_SETTINGS_BYTE_LENGTH);return e.writeFloat32(this.settings.gamma),e.buffer}serialiseComputeSettings(){const e=new f(h.COMPUTE_SETTINGS_BYTE_LENGTH);return e.writeUint32(this.settings.numberOfSteps),e.buffer}createRenderTexture(){return this.device.createTexture({label:"Render Texture",format:"rgba8unorm",size:[this.canvas.width,this.canvas.height],usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT})}createRenderBindGroup(){return this.device.createBindGroup({label:"Renderer Bind Group",layout:this.renderBindGroupLayout,entries:[{binding:0,resource:{buffer:this.renderSettingsBuffer}},{binding:1,resource:this.renderTexture.createView()},{binding:2,resource:this.sampler}]})}createComputeBindGroup(){return this.device.createBindGroup({label:"Compute Bind Group",layout:this.computeBindGroupLayout,entries:[{binding:0,resource:{buffer:this.computeSettingsBuffer}},{binding:1,resource:{buffer:this.camera.buffer}},{binding:2,resource:{buffer:this.blackHole.buffer}},{binding:3,resource:this.renderTexture.createView()},{binding:4,resource:this.skybox.texture.createView({dimension:"cube"})},{binding:5,resource:this.sampler}]})}async initialise(){this.initialised||(this.blackHole.initialise(this.device),this.camera.initialise(this.device),await this.initialiseRendering(),await this.initialiseCompute(),this.updateSettings(),new ResizeObserver(e=>{const t=e[0],i=t.devicePixelContentBoxSize[0].inlineSize,s=t.devicePixelContentBoxSize[0].blockSize;this.canvas.width=i,this.canvas.height=s,this.renderTexture.destroy(),this.camera.setImageDimensions(i,s),this.renderTexture=this.createRenderTexture(),this.renderBindGroup=this.createRenderBindGroup(),this.computeBindGroup=this.createComputeBindGroup(),this.render()}).observe(this.canvas),this.initialised=!0)}async initialiseRendering(){this.ctx.configure({device:this.device,format:this.canvasFormat}),this.skybox=await w.createCubemap(this.device,"Skybox Texture","skybox"),this.renderSettingsBuffer=this.device.createBuffer({label:"Render Settings Buffer",size:h.RENDER_SETTINGS_BYTE_LENGTH,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.renderTexture=this.createRenderTexture(),this.sampler=this.device.createSampler({label:"Renderer Texture Sampler",minFilter:"linear",magFilter:"linear"});const e=await d.fetch(this.device,E("shaders/render.wgsl"));this.renderBindGroupLayout=this.device.createBindGroupLayout({label:"Renderer Bind Group Layout",entries:[{binding:0,buffer:{},visibility:GPUShaderStage.FRAGMENT},{binding:1,texture:{},visibility:GPUShaderStage.FRAGMENT},{binding:2,sampler:{},visibility:GPUShaderStage.FRAGMENT}]}),this.renderBindGroup=this.createRenderBindGroup();const t=this.device.createPipelineLayout({label:"Renderer Render Pipeline Layout",bindGroupLayouts:[this.renderBindGroupLayout]});this.renderPipeline=this.device.createRenderPipeline({label:"Renderer Render Pipeline",layout:t,vertex:{module:e.shader,entryPoint:"vertexMain"},fragment:{module:e.shader,entryPoint:"fragmentMain",targets:[{format:this.canvasFormat}]}})}async initialiseCompute(){this.computeSettingsBuffer=this.device.createBuffer({label:"Compute Settings Buffer",size:h.COMPUTE_SETTINGS_BYTE_LENGTH,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM});const e=await d.fetch(this.device,E("shaders/simulation.wgsl"));this.computeBindGroupLayout=this.device.createBindGroupLayout({label:"Compute Bind Group Layout",entries:[{binding:0,buffer:{},visibility:GPUShaderStage.COMPUTE},{binding:1,buffer:{},visibility:GPUShaderStage.COMPUTE},{binding:2,buffer:{},visibility:GPUShaderStage.COMPUTE},{binding:3,storageTexture:{access:"write-only",format:"rgba8unorm"},visibility:GPUShaderStage.COMPUTE},{binding:4,texture:{viewDimension:"cube"},visibility:GPUShaderStage.COMPUTE},{binding:5,sampler:{},visibility:GPUShaderStage.COMPUTE}]}),this.computeBindGroup=this.createComputeBindGroup();const t=this.device.createPipelineLayout({label:"Compute Pipeline Layout",bindGroupLayouts:[this.computeBindGroupLayout]});this.computePipeline=this.device.createComputePipeline({label:"Compute Pipeline",layout:t,compute:{module:e.shader,entryPoint:"main"}})}updateSettings(){this.device.queue.writeBuffer(this.renderSettingsBuffer,0,this.serialiseRenderSettings()),this.device.queue.writeBuffer(this.computeSettingsBuffer,0,this.serialiseComputeSettings())}render(){this.compute(),this.renderToCanvas()}compute(){const e=this.device.createCommandEncoder(),t=this.gpuTimer.beginComputePass(e);t.setBindGroup(0,this.computeBindGroup),t.setPipeline(this.computePipeline),t.dispatchWorkgroups(Math.ceil(this.canvas.width/8),Math.ceil(this.canvas.height/8),1),t.end(),this.device.queue.submit([e.finish()])}renderToCanvas(){const e=this.device.createCommandEncoder(),t=e.beginRenderPass({colorAttachments:[{view:this.ctx.getCurrentTexture().createView(),loadOp:"clear",storeOp:"store"}]});t.setBindGroup(0,this.renderBindGroup),t.setPipeline(this.renderPipeline),t.draw(3),t.end(),this.device.queue.submit([e.finish()])}static async create(e,t={}){if(!("gpu"in navigator))throw new Error("WebGPU not supported");const i=await navigator.gpu.requestAdapter();if(i===null)throw new Error("Could not find suitable GPU Adapter");const s=await i.requestDevice({requiredFeatures:["timestamp-query"]});if(s===null)throw new Error("Could not find suitable GPU Device");return new h(e,t,s)}}class G{settings;callbacks=[];frameID;lastFrameTime;totalTime;constructor(e={}){this.frameID=null,this.lastFrameTime=0,this.totalTime=0,this.callbacks=[],this.settings={wormholeThreshold:e.wormholeThreshold??500}}start(){this.running||(this.totalTime=0,this.lastFrameTime=-1,this.frameID=requestAnimationFrame(this.tick.bind(this)))}stop(){this.running&&(cancelAnimationFrame(this.frameID),this.frameID=null)}toggle(){this.running?this.stop():this.start()}addCallback(e){this.callbacks.push(e)}tick(e){this.lastFrameTime<0&&(this.lastFrameTime=e);const t=e-this.lastFrameTime,i=this.totalTime+t;if(t<this.settings.wormholeThreshold){const s={deltaTime:t,totalTime:i};for(const r of this.callbacks)r(s);this.totalTime=i}this.lastFrameTime=e,this.frameID=requestAnimationFrame(this.tick.bind(this))}get running(){return this.frameID!==null}}function U(a){x(),C("gamma",e=>{a.settings.gamma=e,a.updateSettings(),a.render()},2)}function x(){const a=document.getElementById("chevron"),e=document.getElementById("content");if(a===null)throw new Error("Could not find chevron element");if(e===null)throw new Error("Could not find info panel");a.addEventListener("click",()=>{a.classList.toggle("collapsed"),e.classList.toggle("collapsed")})}function C(a,e,t=2){const i=`${a}Input`,s=`${a}Value`,r=document.getElementById(i),n=document.getElementById(s);if(r===null)throw new Error(`Could not find slider with id ${i}`);if(n===null)throw new Error(`Could not find value display with id ${n}`);r.addEventListener("change",()=>{const o=parseFloat(r.value);n.textContent=`(${o.toFixed(t)})`,e(o)})}async function R(){const a=document.getElementById("main"),e=document.getElementById("frameTime"),t=document.getElementById("fps"),i=await h.create(a,{gamma:1,numberOfSteps:100,timing:{frameTimeElement:e,fpsElement:t}});await i.initialise(),U(i),i.camera.position.x=i.blackHole.schwarzschildRadius*Math.SQRT1_2*5,i.camera.position.z=i.blackHole.schwarzschildRadius*Math.SQRT1_2*5;const s=new G,r=5e-4,n=o=>{i.camera.lookAt.x=i.camera.position.x+Math.max(1,i.camera.position.x)*Math.cos(o*r),i.camera.lookAt.z=i.camera.position.z+Math.max(1,i.camera.position.z)*Math.sin(-o*r),i.camera.updateBuffer()};s.addCallback(o=>{n(o.totalTime),i.render()}),n(0),s.start()}R().catch(a=>{const e=a instanceof Error?a.message:JSON.stringify(a),t=document.getElementById("alert");t!==null&&(t.classList.add("error"),t.textContent=e),console.error(e)});
