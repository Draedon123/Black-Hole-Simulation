(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))i(s);new MutationObserver(s=>{for(const r of s)if(r.type==="childList")for(const a of r.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&i(a)}).observe(document,{childList:!0,subtree:!0});function t(s){const r={};return s.integrity&&(r.integrity=s.integrity),s.referrerPolicy&&(r.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?r.credentials="include":s.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function i(s){if(s.ep)return;s.ep=!0;const r=t(s);fetch(s.href,r)}})();class n{components;constructor(e=0,t=0,i=0){this.components=new Float32Array(3),this.components[0]=e,this.components[1]=t,this.components[2]=i}static scale(e,t){return new n(e.components[0]*t,e.components[1]*t,e.components[2]*t)}static add(e,t){return e.clone().add(t)}static subtract(e,t){return e.clone().subtract(t)}static cross(e,t){const i=e.components[0],s=e.components[1],r=e.components[2],a=t.components[0],h=t.components[1],o=t.components[2];return new n(s*o-r*h,r*a-i*o,i*h-s*a)}add(e){return this.components[0]+=e.components[0],this.components[1]+=e.components[1],this.components[2]+=e.components[2],this}subtract(e){return this.components[0]-=e.components[0],this.components[1]-=e.components[1],this.components[2]-=e.components[2],this}scale(e){return this.components[0]*=e,this.components[1]*=e,this.components[2]*=e,this}normalise(){const e=1/this.magnitude;return this.components[0]*=e,this.components[1]*=e,this.components[2]*=e,this}clone(){return new n(this.components[0],this.components[1],this.components[2])}get magnitude(){return Math.hypot(this.components[0],this.components[1],this.components[2])}get x(){return this.components[0]}get y(){return this.components[1]}get z(){return this.components[2]}set x(e){this.components[0]=e}set y(e){this.components[1]=e}set z(e){this.components[2]=e}}class m{buffer;dataview;littleEndian;offset;constructor(e,t=!0,i=0){this.buffer=new ArrayBuffer(e),this.dataview=new DataView(this.buffer),this.littleEndian=t,this.offset=i}writeUint8(e){this.dataview.setUint8(this.offset,e),this.offset+=1}writeFloat32(e){this.dataview.setFloat32(this.offset,e,this.littleEndian),this.offset+=4}writeUint32(e){this.dataview.setUint32(this.offset,e,this.littleEndian),this.offset+=4}writeVec3f(e){this.writeFloat32(e.x),this.writeFloat32(e.y),this.writeFloat32(e.z)}writeMat4x4f(e){for(let t=0;t<16;t++)this.writeFloat32(e.components[t])}pad(e){this.offset+=e}}function b(u){return`/Black-Hole-Simulation/${u}`}const E=66743e-15,w=299792458;class f{static BYTE_LENGTH=5*Float32Array.BYTES_PER_ELEMENT+3*Float32Array.BYTES_PER_ELEMENT;buffer;initialised;device;position;mass;radius;constructor(e={}){this.initialised=!1,this.position=e.position??new n,this.mass=e.mass??1e31,this.radius=e.radius??1e7}initialise(e){this.initialised||(this.device=e,this.buffer=this.device.createBuffer({label:"Black Hole Buffer",size:f.BYTE_LENGTH,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.initialised=!0,this.updateBuffer())}updateBuffer(){this.initialised||console.error("Black Hole not initialised"),this.device.queue.writeBuffer(this.buffer,0,this.serialise())}serialise(){const e=new m(f.BYTE_LENGTH);return e.writeVec3f(this.position),e.writeFloat32(this.mass),e.writeFloat32(this.schwarzschildRadius),e.buffer}get schwarzschildRadius(){return 2*E*this.mass/(w*w)}}class p{static BYTE_LENGTH=18*Float32Array.BYTES_PER_ELEMENT+2*Float32Array.BYTES_PER_ELEMENT;static GLOBAL_UP=new n(0,1,0);imageWidth;imageHeight;fieldOfView;position;lookAt;up;right;back;viewportDeltaU;viewportDeltaV;pixel00;initialised;device;buffer;constructor(e={}){this.imageWidth=e.imageWidth??1920,this.imageHeight=e.imageHeight??1080,this.fieldOfView=e.fieldOfView??Math.PI/3,this.position=e.position??new n,this.lookAt=e.lookAt??new n(0,0,-1),this.initialised=!1}serialise(){const e=new m(p.BYTE_LENGTH);return e.writeVec3f(this.position),e.pad(4),e.writeVec3f(this.viewportDeltaU),e.pad(4),e.writeVec3f(this.viewportDeltaV),e.pad(4),e.writeVec3f(this.pixel00),e.pad(4),e.writeFloat32(this.imageWidth),e.writeFloat32(this.imageHeight),e.buffer}initialise(e){this.initialised||(this.device=e,this.buffer=e.createBuffer({label:"Camera Buffer",size:p.BYTE_LENGTH,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.initialised=!0,this.updateBuffer())}updateBuffer(){if(!this.initialised)return;const e=this.imageWidth/this.imageHeight,t=n.subtract(this.position,this.lookAt).magnitude;if(t<1e-8){console.error("Look At is too close to Position. Buffer not updated");return}const i=2*t*Math.tan(this.fieldOfView/2),s=e*i;this.back=n.subtract(this.position,this.lookAt).normalise(),this.right=n.cross(p.GLOBAL_UP,this.back),this.up=n.cross(this.back,this.right);const r=n.scale(this.right,s),a=n.scale(this.up,i);this.viewportDeltaU=n.scale(r,1/this.imageWidth),this.viewportDeltaV=n.scale(a,1/this.imageHeight);const h=this.position.clone().subtract(n.scale(this.back,t));this.pixel00=h.subtract(n.add(r,a).scale(.5)).add(n.add(this.viewportDeltaU,this.viewportDeltaV).scale(.5)),this.device.queue.writeBuffer(this.buffer,0,this.serialise())}setImageDimensions(e,t){this.imageWidth=e,this.imageHeight=t,this.updateBuffer()}get aspectRatio(){return this.imageWidth/this.imageHeight}}class d{shader;constructor(e,t,i){this.shader=e.createShaderModule({label:i,code:t})}static async fetch(e,t,i){const s=await(await fetch(t)).text(),r=await d.preprocess(t,s);return new d(e,r,i)}static async preprocess(e,t){return d.resolveImports(e,t)}static async resolveImports(e,t,i=[]){const s=/#!import.*\s/g,r=e.split("/"),a=r.slice(0,r.length-1).join("/")+"/",h=t.match(s)?.map(c=>c.replaceAll(/(#!import)|\s/g,"")).filter(c=>!i.includes(c)).map(c=>a+c+".wgsl")??[];return((await Promise.all(h.map(async c=>{const T=await(await fetch(c)).text();return d.resolveImports(c,T,i)}))).join("")+t).replaceAll(s,"")}}class g{label;texture;constructor(e,t){this.label=e,this.texture=t}static async create(e,t,...i){const s=i.map(async o=>await(await fetch(b(o))).blob()),r=await Promise.all(s),a=await Promise.all(r.map(o=>createImageBitmap(o))),h=e.createTexture({label:t,format:"rgba8unorm",size:[a[0].width,a[0].height,a.length],usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});for(let o=0;o<a.length;o++){const c=a[o];e.queue.copyExternalImageToTexture({source:c},{texture:h,origin:[0,0,o]},{width:c.width,height:c.height})}return new g(t,h)}static async createCubemap(e,t,i){return await g.create(e,t,`${i}/px.png`,`${i}/nx.png`,`${i}/py.png`,`${i}/ny.png`,`${i}/pz.png`,`${i}/nz.png`)}}class l{static RENDER_SETTINGS_BYTE_LENGTH=1*Float32Array.BYTES_PER_ELEMENT;static COMPUTE_SETTINGS_BYTE_LENGTH=1*Float32Array.BYTES_PER_ELEMENT;canvas;camera;settings;device;ctx;canvasFormat;blackHole;initialised;skybox;renderSettingsBuffer;renderBindGroupLayout;renderBindGroup;renderPipeline;renderTexture;sampler;computeSettingsBuffer;computeBindGroupLayout;computeBindGroup;computePipeline;constructor(e,t,i){const s=e.getContext("webgpu");if(s===null)throw new Error("Could not create WebGPU Canvas Context");this.canvas=e,this.device=i,this.ctx=s,this.canvasFormat="rgba8unorm",this.camera=new p,this.blackHole=new f(t.blackHole),this.initialised=!1,this.settings={gamma:t.gamma??1.5,numberOfSteps:t.numberOfSteps??1e3}}serialiseRenderSettings(){const e=new m(l.RENDER_SETTINGS_BYTE_LENGTH);return e.writeFloat32(this.settings.gamma),e.buffer}serialiseComputeSettings(){const e=new m(l.COMPUTE_SETTINGS_BYTE_LENGTH);return e.writeUint32(this.settings.numberOfSteps),e.buffer}createRenderTexture(){return this.device.createTexture({label:"Render Texture",format:"rgba8unorm",size:[this.canvas.width,this.canvas.height],usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT})}createRenderBindGroup(){return this.device.createBindGroup({label:"Renderer Bind Group",layout:this.renderBindGroupLayout,entries:[{binding:0,resource:{buffer:this.renderSettingsBuffer}},{binding:1,resource:this.renderTexture.createView()},{binding:2,resource:this.sampler}]})}createComputeBindGroup(){return this.device.createBindGroup({label:"Compute Bind Group",layout:this.computeBindGroupLayout,entries:[{binding:0,resource:{buffer:this.computeSettingsBuffer}},{binding:1,resource:{buffer:this.camera.buffer}},{binding:2,resource:{buffer:this.blackHole.buffer}},{binding:3,resource:this.renderTexture.createView()},{binding:4,resource:this.skybox.texture.createView({dimension:"cube"})},{binding:5,resource:this.sampler}]})}async initialise(){this.initialised||(this.blackHole.initialise(this.device),this.camera.initialise(this.device),await this.initialiseRendering(),await this.initialiseCompute(),new ResizeObserver(e=>{const t=e[0],i=t.devicePixelContentBoxSize[0].inlineSize,s=t.devicePixelContentBoxSize[0].blockSize;this.canvas.width=i,this.canvas.height=s,this.renderTexture.destroy(),this.camera.setImageDimensions(i,s),this.renderTexture=this.createRenderTexture(),this.renderBindGroup=this.createRenderBindGroup(),this.computeBindGroup=this.createComputeBindGroup(),this.render()}).observe(this.canvas),this.initialised=!0)}async initialiseRendering(){this.ctx.configure({device:this.device,format:this.canvasFormat}),this.skybox=await g.createCubemap(this.device,"Skybox Texture","skybox"),this.renderSettingsBuffer=this.device.createBuffer({label:"Render Settings Buffer",size:l.RENDER_SETTINGS_BYTE_LENGTH,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.device.queue.writeBuffer(this.renderSettingsBuffer,0,this.serialiseRenderSettings()),this.renderTexture=this.createRenderTexture(),this.sampler=this.device.createSampler({label:"Renderer Texture Sampler",minFilter:"linear",magFilter:"linear"});const e=await d.fetch(this.device,b("shaders/render.wgsl"));this.renderBindGroupLayout=this.device.createBindGroupLayout({label:"Renderer Bind Group Layout",entries:[{binding:0,buffer:{},visibility:GPUShaderStage.FRAGMENT},{binding:1,texture:{},visibility:GPUShaderStage.FRAGMENT},{binding:2,sampler:{},visibility:GPUShaderStage.FRAGMENT}]}),this.renderBindGroup=this.createRenderBindGroup();const t=this.device.createPipelineLayout({label:"Renderer Render Pipeline Layout",bindGroupLayouts:[this.renderBindGroupLayout]});this.renderPipeline=this.device.createRenderPipeline({label:"Renderer Render Pipeline",layout:t,vertex:{module:e.shader,entryPoint:"vertexMain"},fragment:{module:e.shader,entryPoint:"fragmentMain",targets:[{format:this.canvasFormat}]}})}async initialiseCompute(){this.computeSettingsBuffer=this.device.createBuffer({label:"Compute Settings Buffer",size:l.COMPUTE_SETTINGS_BYTE_LENGTH,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM}),this.device.queue.writeBuffer(this.computeSettingsBuffer,0,this.serialiseComputeSettings());const e=await d.fetch(this.device,b("shaders/simulation.wgsl"));this.computeBindGroupLayout=this.device.createBindGroupLayout({label:"Compute Bind Group Layout",entries:[{binding:0,buffer:{},visibility:GPUShaderStage.COMPUTE},{binding:1,buffer:{},visibility:GPUShaderStage.COMPUTE},{binding:2,buffer:{},visibility:GPUShaderStage.COMPUTE},{binding:3,storageTexture:{access:"write-only",format:"rgba8unorm"},visibility:GPUShaderStage.COMPUTE},{binding:4,texture:{viewDimension:"cube"},visibility:GPUShaderStage.COMPUTE},{binding:5,sampler:{},visibility:GPUShaderStage.COMPUTE}]}),this.computeBindGroup=this.createComputeBindGroup();const t=this.device.createPipelineLayout({label:"Compute Pipeline Layout",bindGroupLayouts:[this.computeBindGroupLayout]});this.computePipeline=this.device.createComputePipeline({label:"Compute Pipeline",layout:t,compute:{module:e.shader,entryPoint:"main"}})}render(){this.compute(),this.renderToCanvas()}compute(){const e=this.device.createCommandEncoder(),t=e.beginComputePass();t.setBindGroup(0,this.computeBindGroup),t.setPipeline(this.computePipeline),t.dispatchWorkgroups(Math.ceil(this.canvas.width/8),Math.ceil(this.canvas.height/8),1),t.end(),this.device.queue.submit([e.finish()])}renderToCanvas(){const e=this.device.createCommandEncoder(),t=e.beginRenderPass({colorAttachments:[{view:this.ctx.getCurrentTexture().createView(),loadOp:"clear",storeOp:"store"}]});t.setBindGroup(0,this.renderBindGroup),t.setPipeline(this.renderPipeline),t.draw(3),t.end(),this.device.queue.submit([e.finish()])}static async create(e,t={}){if(!("gpu"in navigator))throw new Error("WebGPU not supported");const i=await navigator.gpu.requestAdapter();if(i===null)throw new Error("Could not find suitable GPU Adapter");const s=await i.requestDevice();if(s===null)throw new Error("Could not find suitable GPU Device");return new l(e,t,s)}}class B{settings;callbacks=[];frameID;lastFrameTime;totalTime;constructor(e={}){this.frameID=null,this.lastFrameTime=0,this.totalTime=0,this.callbacks=[],this.settings={wormholeThreshold:e.wormholeThreshold??500}}start(){this.running||(this.totalTime=0,this.frameID=requestAnimationFrame(this.tick.bind(this)))}stop(){this.running&&(cancelAnimationFrame(this.frameID),this.frameID=null)}toggle(){this.running?this.stop():this.start()}addCallback(e){this.callbacks.push(e)}tick(e){const t=e-this.lastFrameTime,i=this.totalTime+t;if(t<this.settings.wormholeThreshold){const s={deltaTime:t,totalTime:i};for(const r of this.callbacks)r(s);this.totalTime=i}this.lastFrameTime=e,this.frameID=requestAnimationFrame(this.tick.bind(this))}get running(){return this.frameID!==null}}async function G(){const u=document.getElementById("main"),e=await l.create(u,{gamma:1,numberOfSteps:100});await e.initialise(),e.camera.position.x=e.blackHole.schwarzschildRadius*Math.SQRT1_2*5,e.camera.position.z=e.blackHole.schwarzschildRadius*Math.SQRT1_2*5;const t=new B;t.addCallback(()=>{e.render()}),t.start()}G().catch(u=>{const e=u instanceof Error?u.message:JSON.stringify(u),t=document.getElementById("info");t!==null&&(t.classList.add("error"),t.textContent=e),console.error(e)});
